## Effective-Java-3rd

Effective Java 인프런 백기선님, 강의와 Effective Java 3판 책을 스터디하면서 작성된 코드입니다.  

---

### Features

(1) 아이템1.생성자 대신 정적 팩토리 메서드를 **고려**하라.
* (장점)
  * 이름을 가질 수 있다. (명시적 방법, 동일한 시그니처를 가진 생성자를 생성할 수 없다.)
  * 호출될 때마다 생성자를 새롭게 생성하지 않아도 된다. (예) ```Boolean.valueOf```
    (Flyweight Pattern)
  * 반환 타입에서 하위 객체를 반환할 수 있다.
  * 입력 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다. (예) ```EnumSet```
  * 정적 팩토리 매서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. (서비스 프로바이더)
* (단점)
  * 상속이 필요한 경우 사용하기 어렵다. (정적 팩토리만 존재하는 경우 하위 클래스를 만들수 없다)
  * 프로그래머가 찾기가 어렵다. javadoc 메소드가 많은 경우에 static method 를 찾기가 어렵다. ```of``` 와 같은 특정 명명규칙을 이용하여 찾기 쉽게 만들 수 있다. 가장 좋은 방법은 문서화를 하는 것이다.
* 추가적으로?
  * 열거 타입은 인스턴스가 하나만 존재함을 보장한다.
    * 상수 목록을 담는 데이터 타입
    * 타입 안정성 제공
    * 싱글톤 패턴
  * 객체가 자주 요청된다면 플라이웨이트 패턴을 사용할 수 있다.
  * 자바 8부터 인터페이스가 정적 메서드를 가질 수 있다.
  * 서비스 제공자 프레임워크를 만드는 기반이 되었다.
    * 다양한 변경: 브릿지 패턴, 의존 객체 프레임워크, ```java.util.ServiceLoader```
  * 서비스 제공자 인터페이스가 없다면 각 구현체를 리플렉션을 사용해야 한다.
  * 브릿지 패턴
  * 의존 객체 주입 프레임워크

(2) 아이템2.생성자에 매개변수가 많다면 빌더를 고려해라.
* 정적 팩토리와 생성자에 선택적 매개변수가 많을 때 고려할 수 있는 방안
  * 대안1: 점층적 생성자 패턴 또는 생성자 체이닝
  * 대안2: 자바빈즈 패턴 (객체를 여러 번 호출하여 객체를 생성 - 불완전한 객체가 생성될 수 있음)
    * 불변객체를 만들기 어렵다.
    * 대신 ```freezing``` 기능을 사용한다. (현업에서 거의 사용되지 않는다.)
  * 추천대안: 빌더 (무조건 좋지는 않지만 좋은 대안이 되는 경우가 있음)
    * 불변객체가 필요하다.
    * 선택적 매개변수와 필수 매개변수가 혼합되어 있는 경우
  * 계층적 빌더
* 정리 해 보기
  * p15. 자바빈즈
    * ```java.beans``` package 내부에 정의
    * ```getter``` & ```setter``` 메소드 이름 정의
    * Serializable Interface 구현
    * 스펙 중에 ```getter``` & ```setter``` 를 주로 쓰는 이유: 여러 프레임워크에서 리플렉션을 통해 객체의 값을 조회하거나 설정하기 때문이다.
  * p17. 객체 얼리기(freezing)
    * 임의의 객체를 불변객체로 만들어 준다.
  * p17. 빌더 패턴
  * p19. ```IllegalArgumentException```
    * RuntimeException (복구할 방법이 없음)
    * checked exception(컴파일, 복구가능한 상황) vs unchecked exception(런타임, 복구 불가능)
    * 최소한 어떤 매개변수가 잘못되었는 지 알려 주는게 좋다.
    * 선언하는 경우는 무엇인가? 클라이언트한테 명시적으로 알려주고 싶을 때
  * p20. 재귀적인 한정 타입을 이용한 제네릭 타입
  * p21. 가변인수(varargs) 매개변수를 여러 개 사용할 수 있다.
    * 여러 인자를 받을 수 있음

(3) 아이템3.생성자나 열거 타입으로 싱글턴임을 보증하라.
* 첫번째 방법: private 생성자 + ```public static final``` 필드
  * 싱글톤
  * 단점1) 싱글톤은 테스트 하기가 어렵다.
  * 단점2) 리플렉션으로 private 생성자를 호출할 수 있다.
  * 단점3) 역직렬화할 때 새로운 인스턴스가 생성된다.
* 두번째 방법: private 생성자 + ```public static``` method
* 세번재 방법: 제네릭 싱글톤 팩토리 (원하는 타입으로 형변환을 해줄 수 있다) ```==``` 비교가 안됨
* 네번째 방법: ```Supplier```
---